{"file_contents":{"CreateAccout.py":{"content":"import json\nimport os\nimport random\nimport string\nimport bcrypt\nimport shutil\nfrom fastapi import FastAPI\nimport uvicorn\nimport sched\nimport time\nimport subprocess\nimport asyncio\nfrom pydantic import BaseModel\napp = FastAPI()\n\n\n\nparentfolder = os.path.dirname(os.path.abspath(__file__))\nprint(parentfolder)\n\nUserIDList = []\nTokenDict = {}  #\"Name\":\"Token\"\n\n#XP to level y = 200*y \n\n@app.get(\"/\")\ndef index():\n    return {\"log\": \"MeteorBackend\"}\n\n@app.get(\"/login/createaccount\")\ndef appcreateacc(ID: str, Pass: str) -> dict[str, str]:\n    return createaccount(ID, Pass)\n\n@app.get(\"/login/connect\")\ndef appconnect(ID:str, Pass:str) -> dict[str,str]:\n    return auth(ID, Pass)\n\n@app.get(\"/login/logout\")\ndef applogout(Token: str):\n    JFile = getuserfilebytoken(Token)\n    if JFile == \"MissingToken\":\n        return {\"log\": \"TokenDoesNotExist\"}\n    removetoken(JFile[\"AccountName\"])\n    return {\"log\": \"ok\"}\n\n@app.get(\"/login/connectbytoken\")\ndef appconnectbytoken(Token: str):\n    JFile = getuserfilebytoken(Token)\n    if JFile == \"MissingToken\":\n        return {\"log\": \"TokenDoesNotExist\"}\n    return {\"log\": \"ok\", \"username\": JFile[\"AccountName\"]}\n\n@app.get(\"/account/locker/getlocker\")\ndef appgetlocker(Token: str):\n    JFile = getuserfilebytoken(Token)\n    if JFile == \"MissingToken\":\n        return {\"log\": \"Token does not exist\"}\n    return {\"log\": \"ok\", \"skins\": JFile[\"Locker\"][\"Skins\"], \"backpacks\": JFile[\"Locker\"][\"Backpacks\"], \"pickaxes\": JFile[\"Locker\"][\"Pickaxes\"], \"gliders\": JFile[\"Locker\"][\"Gliders\"], \"contrails\": JFile[\"Locker\"][\"Contrails\"], \"loadingscreens\": JFile[\"Locker\"][\"LoadingScreens\"], \"emotes\": JFile[\"Locker\"][\"Emotes\"]}\n\n@app.get(\"/account/locker/getequippedlocker\")\ndef appgetequippedlocker(Token: str)  -> dict[str, str]:\n    JFile = getuserfilebytoken(Token)\n    if JFile == \"MissingToken\":\n        return {\"log\": \"Token does not exist\"}\n    return {\"log\": \"ok\", \"skin\": JFile[\"Locker\"][\"Skin\"], \"backpack\": JFile[\"Locker\"][\"Backpack\"], \"pickaxe\": JFile[\"Locker\"][\"Pickaxe\"], \"glider\": JFile[\"Locker\"][\"Glider\"], \"contrail\": JFile[\"Locker\"][\"Contrail\"], \"loadingscreen\": JFile[\"Locker\"][\"LoadingScreen\"], \"emote1\": JFile[\"Locker\"][\"Emote1\"], \"emote2\": JFile[\"Locker\"][\"Emote2\"], \"emote3\": JFile[\"Locker\"][\"Emote3\"], \"emote4\": JFile[\"Locker\"][\"Emote4\"], \"emote5\": JFile[\"Locker\"][\"Emote5\"], \"emote6\": JFile[\"Locker\"][\"Emote6\"]}\n\n@app.get(\"/account/locker/setskin\")\ndef appsetskin(Token: str, Name: str):\n    JFile = getuserfilebytoken(Token)\n    if JFile == \"MissingToken\":\n        return {\"log\": \"Token does not exist\"}\n    setskin(JFile[\"AccountName\"], Name)\n    return {\"log\": \"ok\"}\n@app.get(\"/account/locker/setbackpack\")\ndef appsetbackpack(Token: str, Name: str):\n    JFile = getuserfilebytoken(Token)\n    if JFile == \"MissingToken\":\n        return {\"log\": \"Token does not exist\"}\n    setbackpack(JFile[\"AccountName\"], Name)\n    return {\"log\": \"ok\"}\n@app.get(\"/account/locker/setpickaxe\")\ndef appsetpickaxe(Token: str, Name: str):\n    JFile = getuserfilebytoken(Token)\n    if JFile == \"MissingToken\":\n        return {\"log\": \"Token does not exist\"}\n    setpickaxe(JFile[\"AccountName\"], Name)\n    return {\"log\": \"ok\"}\n@app.get(\"/account/locker/setglider\")\ndef appsetglider(Token: str, Name: str):\n    JFile = getuserfilebytoken(Token)\n    if JFile == \"MissingToken\":\n        return {\"log\": \"Token does not exist\"}\n    setglider(JFile[\"AccountName\"], Name)\n    return {\"log\": \"ok\"}\n@app.get(\"/account/locker/setcontrail\")\ndef appsetcontrail(Token: str, Name: str):\n    JFile = getuserfilebytoken(Token)\n    if JFile == \"MissingToken\":\n        return {\"log\": \"Token does not exist\"}\n    setcontrail(JFile[\"AccountName\"], Name)\n    return {\"log\": \"ok\"}\n@app.get(\"/account/locker/setloadingscreen\")\ndef appsetloadingscreen(Token: str, Name: str):\n    JFile = getuserfilebytoken(Token)\n    if JFile == \"MissingToken\":\n        return {\"log\": \"Token does not exist\"}\n    setloadingscreen(JFile[\"AccountName\"], Name)\n    return {\"log\": \"ok\"}\n@app.get(\"/account/locker/setemote1\")\ndef appsetemote1(Token: str, Name: str):\n    JFile = getuserfilebytoken(Token)\n    if JFile == \"MissingToken\":\n        return {\"log\": \"Token does not exist\"}\n    setemote1(JFile[\"AccountName\"], Name)\n    return {\"log\": \"ok\"}\n@app.get(\"/account/locker/setemote2\")\ndef appsetemote2(Token: str, Name: str):\n    JFile = getuserfilebytoken(Token)\n    if JFile == \"MissingToken\":\n        return {\"log\": \"Token does not exist\"}\n    setemote2(JFile[\"AccountName\"], Name)\n    return {\"log\": \"ok\"}\n@app.get(\"/account/locker/setemote3\")\ndef appsetemote3(Token: str, Name: str):\n    JFile = getuserfilebytoken(Token)\n    if JFile == \"MissingToken\":\n        return {\"log\": \"Token does not exist\"}\n    setemote3(JFile[\"AccountName\"], Name)\n    return {\"log\": \"ok\"}\n@app.get(\"/account/locker/setemote4\")\ndef appsetemote4(Token: str, Name: str):\n    JFile = getuserfilebytoken(Token)\n    if JFile == \"MissingToken\":\n        return {\"log\": \"Token does not exist\"}\n    setemote4(JFile[\"AccountName\"], Name)\n    return {\"log\": \"ok\"}\n@app.get(\"/account/locker/setemote5\")\ndef appsetemote5(Token: str, Name: str):\n    JFile = getuserfilebytoken(Token)\n    if JFile == \"MissingToken\":\n        return {\"log\": \"Token does not exist\"}\n    setemote5(JFile[\"AccountName\"], Name)\n    return {\"log\": \"ok\"}\n@app.get(\"/account/locker/setemote6\")\ndef appsetemote6(Token: str, Name: str):\n    JFile = getuserfilebytoken(Token)\n    if JFile == \"MissingToken\":\n        return {\"log\": \"Token does not exist\"}\n    setemote6(JFile[\"AccountName\"], Name)\n    return {\"log\": \"ok\"}\n\n\n@app.get(\"/account/activateBP\")\ndef appactivatebp(Token: str):\n    JFile = getuserfilebytoken(Token)\n    if JFile == \"MissingToken\":\n        return {\"log\": \"Token does not exist\"}\n    if JFile[\"VBucksCount\"] >= 950:\n        activatepremiumpass(JFile[\"AccountName\"])\n        removevbucks(JFile[\"AccountName\"], 950)\n        return {\"log\": \"ok\"}\n    else : \n        return {\"log\": \"notenoughvbucks\"}\n\n@app.get(\"/account/buytiers\")\ndef appbuytiers(Token: str, Tiers: int):\n    JFile = getuserfilebytoken(Token)\n    if JFile == \"MissingToken\":\n        return {\"log\": \"Token does not exist\"}\n    if JFile[\"VBucksCount\"] >= Tiers*150:\n        givebattlestars(JFile[\"AccountName\"], Tiers*10)\n        removevbucks(JFile[\"AccountName\"], Tiers*150)\n        return {\"log\": \"ok\"}\n    else : \n        return {\"log\": \"notenoughvbucks\"}\n\n@app.get(\"/account/xpinfo\")\ndef appgetxpinfo(Token: str):\n    JFile = getuserfilebytoken(Token)\n    if JFile == \"MissingToken\":\n        return {\"log\": \"Token does not exist\"}\n    return {\"log\": \"ok\", \"Level\": JFile[\"Level\"], \"XPIntoLevel\": JFile[\"XPIntoLevel\"]}\n\n@app.get(\"/account/tierinfo\")\ndef appgettierinfo(Token: str):\n    JFile = getuserfilebytoken(Token)\n    if JFile == \"MissingToken\":\n        return {\"log\": \"Token does not exist\"}\n    return {\"log\": \"ok\", \"HasBP\": JFile[\"BattlePassPossessed\"], \"Tier\": JFile[\"BattlePassTier\"], \"BattleStars\": JFile[\"BattleStarsCount\"]}\n\n@app.get(\"/account/vbuckcount\")\ndef appgetvbuckcount(Token: str):\n    JFile = getuserfilebytoken(Token)\n    if JFile == \"MissingToken\":\n        return {\"log\": \"Token does not exist\"}\n    return {\"log\": \"ok\", \"Count\": JFile[\"VBucksCount\"]}\n\n@app.get(\"/account/questlog\")\ndef appgetquestlog(Token: str):\n    JFile = getuserfilebytoken(Token)\n    if JFile == \"MissingToken\":\n        return {\"log\": \"Token does not exist\"}\n    return {\"log\": \"ok\", \"questlog\": JFile[\"ChallengeProgress\"]}\n\n@app.get(\"/account/questset\")\ndef appgetquestset(Token: str, Name: str):\n    JFile = getuserfilebytoken(Token)\n    if JFile == \"MissingToken\":\n        return {\"log\": \"Token does not exist\"}\n    ChallengeSet = open(\"ChallengesSets/\"+Name+\".json\", \"r\")\n    JChallengeSet = json.load(ChallengeSet)\n    return {\"log\": \"ok\", \"questset\": JChallengeSet}\n\n@app.get(\"/account/rewardlist\")\ndef appgetrewardlist(Token: str):\n    JFile = getuserfilebytoken(Token)\n    if JFile == \"MissingToken\":\n        return {\"log\": \"Token does not exist\"}\n    return {\"log\": \"ok\", \"rewardlist\": JFile[\"RewardsToBeClaimed\"]}\n\n@app.get(\"/account/clearrewardlist\")\ndef appclearrewardlist(Token: str):\n    JFile = getuserfilebytoken(Token)\n    if JFile == \"MissingToken\":\n        return {\"log\": \"Token does not exist\"}\n    clearrewardlist(JFile[\"AccountName\"])\n    return {\"log\": \"ok\"}\n\nclass ChallengeRequest(BaseModel):\n    Token: str\n    ChallengeUp: str\n\n\n@app.post(\"/account/updatechallenges\")\ndef appupdatechallenges(request: ChallengeRequest):\n    Token = request.Token\n    ChallengeUp = json.loads(request.ChallengeUp)\n    JFile = getuserfilebytoken(Token)\n    if JFile == \"MissingToken\":\n        return {\"log\": \"Token does not exist\"}\n    progresschallenges(JFile[\"AccountName\"], ChallengeUp)\n    return {\"log\": \"ok\"}\n\n@app.get(\"/account/finishgame\")\ndef appfinishgame(Token: str, GameStats): #elim,assist,revive,placement,maxplayers,chest,ammobox,gamemode\n    JFile = getuserfilebytoken(Token)\n    if JFile == \"MissingToken\":\n        return {\"log\": \"Token does not exist\"}\n    JGS = json.loads(GameStats)\n    #addmatchtostats(JFile[\"AccountName\"], GameStats)\n    givexp(JFile[\"AccountName\"], JGS[\"elim\"]*100 + JGS[\"assist\"]*25 + JGS[\"revive\"]*50 + getplacementXP(JGS[\"placement\"], JGS[\"maxplayers\"]) + JGS[\"chest\"]*10 + JGS[\"ammobox\"]*5)\n    return {\"log\": \"ok\"}\n\n@app.get(\"/account/lastmatches\")\ndef appgetlastmatches(Token: str):\n    JFile = getuserfilebytoken(Token)\n    if JFile == \"MissingToken\":\n        return {\"log\": \"Token does not exist\"}\n    return {\"log\": \"ok\", \"lastmatches\": JFile[\"PreviousMatches\"]}\n\n\n@app.get(\"/news\")\ndef appgetnews():\n    JNews = json.load(open(\"News.json\", \"r\"))\n    return JNews\n\n@app.get(\"/shop\")\ndef appgetshop():\n    JShop = json.load(open(\"Shop/Shop.json\", \"r\"))\n    return JShop\n\n@app.get(\"/shop/buy\")\ndef appbuyshop(Player: str, Category: str, ID: int):\n    JShop = json.load(open(\"Shop/Shop.json\", \"r\"))\n    JFile = readuserfile(Player)\n    if not canaffordvbucks(Player, JShop[Category][ID][\"Price\"]):\n        return {\"log\": \"CantAfford\"}\n    givereward(Player, JShop[Category][ID][\"Item\"][\"RewardID\"], JShop[Category][ID][\"Item\"][\"Amount\"], JShop[Category][ID][\"Item\"][\"Note\"])    \n    return {\"log\": \"ok\"}\n\ndef addmatchtostats(Player: str, GameStats):\n    JFile = readuserfile(Player)\n    JFile[\"PreviousMatches\"].append(GameStats)\n    if not GameStats[\"gamemode\"] in JFile[\"Stats\"]:\n        JFile[\"Stats\"][GameStats[\"gamemode\"]] = {\"elim\": 0, \"matchplayed\": 0, \"top1\": 0, \"top3\": 0, \"top6\": 0}\n    JFile[\"Stats\"][GameStats[\"gamemode\"]][\"elim\"] += GameStats[\"elim\"]\n    JFile[\"Stats\"][GameStats[\"gamemode\"]][\"matchplayed\"] +=1\n    if GameStats[\"placement\"] <= 6:\n        JFile[\"Stats\"][GameStats[\"gamemode\"]][\"top6\"] +=1\n        if GameStats[\"placement\"] <= 3:\n            JFile[\"Stats\"][GameStats[\"gamemode\"]][\"top3\"] +=1\n            if GameStats[\"placement\"] == 1:\n                JFile[\"Stats\"][GameStats[\"gamemode\"]][\"top1\"] +=1\n    with open(\"Accounts/\"+Player+\".json\", \"w\") as savefile:\n        json.dump(JFile, savefile, indent=4)\n    return\n\n\n\n\ndef getplacementXP(place: int, playernb: int):\n    if place == 1:\n        return 1000\n    if place == 2:\n        return 750\n    if place == 3:\n        return 500\n    return int(round(((playernb-place)/playernb)*500))\n\ndef createuserfile(ID : str):\n    shutil.copy(\"DefaultAccount.json\", \"Accounts/\"+ID+\".json\")\n    with open(\"Accounts/\"+ID+\".json\", \"r\") as file:\n        print(\"Created account named\", ID)\n        UserIDList.append(ID)\n        jfile=readuserfile(ID)\n        jfile[\"AccountName\"] = ID\n        with open(\"Accounts/\"+ID+\".json\", \"w\") as savefile:\n            json.dump(jfile, savefile, indent=4)\n        file.close\n        return\n\ndef readuserfile(ID):\n    with open(\"Accounts/\"+ID+\".json\") as file:\n        return json.load(file)\n\ndef addtoken(ID):\n\n    Token = ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(30))\n    TokenDict[ID]= Token\n    print(\"Created token for\", ID)\n    return Token\n\ndef removetoken(ID):\n    if ID in TokenDict:\n        del TokenDict[ID]\n        print(ID+\"'s token deleted.\")\n        return\n    else:\n        print(ID+\"'s token could not be deleted as it didn't exist\")\n        return\n\ndef getuserfilebytoken(Token):\n    FoundPlayer = [key for key, value in TokenDict.items() if value == Token]\n    if len(FoundPlayer) == 1:\n        return readuserfile(FoundPlayer[0])\n    else:\n        print(\"Token not found\")\n        return \"MissingToken\"\n\n\n\ndef setpass(ID, Pass):\n    jfile=readuserfile(ID)\n    jfile[\"Pass\"] = Pass.decode(\"utf-8\")\n    with open(\"Accounts/\"+ID+\".json\", \"w\") as savefile:\n        json.dump(jfile, savefile, indent=4)\n    print(\"SetPassword\")\n    return\n\ndef createaccount(ID: str, Pass: str):\n    \n    if not os.path.exists(\"Accounts/\"+ID+\".json\") :\n        if len(ID)<=2:\n            print(\"Account was not created as ID is too short\")\n            return {\"Log\": \"IDTooShort\"}\n        if len(Pass)<=8:\n            print(\"Account was not created as pass is too short\")\n            return {\"log\": \"PassTooShort\"}\n        Hash = bcrypt.hashpw(Pass.encode('utf-8'), bcrypt.gensalt())\n        createuserfile(ID)\n        setpass(ID, Hash)\n        return{\"log\": \"AccountCreated\", \"Token\": addtoken(ID)}\n\n    else:\n        print(\"Could not create account\", ID, \"as another account already has that name\")\n        return {\"Log\": \"ExistingID\"}\n\ndef auth(ID: str, Pass: str):\n    if not os.path.exists(\"Accounts/\"+ID+\".json\"):\n        print(\"Connection failed, username does not exist.\")\n        return {\"log\": \"UserNameNotExist\"}\n    JFile = readuserfile(ID)\n    AccPass = JFile[\"Pass\"]\n    if bcrypt.checkpw(Pass.encode('utf-8'), AccPass.encode('utf-8')):\n        print(ID, \"connected successfully.\")\n        return {\"log\": \"ConnectionOK\", \"token\": addtoken(ID)}\n    else:\n        print(ID, \"input a wrong pass.\")\n        return {\"log\": \"PassWrong\"}\n\ndef getxptolevel(lvl: int):\n    return 200*lvl\n\ndef getxp(ID: str):\n    JFile = readuserfile(ID)\n    return JFile[\"Level\"], JFile[\"XPIntoLevel\"]\n\ndef getacclvl(ID : str):\n    JFile = readuserfile(ID)\n    return JFile[\"AccountLevel\"]\n\ndef getbattlestarperlvl(lvl: int):\n    if lvl%10 == 0:\n        return 10\n    if lvl%5 == 0:\n        return 5\n    return 2\n\ndef givexp(ID: str, Amount: int):\n    XPToGive = Amount\n    Lvl, XPIntoLvl = getxp(ID)\n    AccLvl = getacclvl(ID)\n    while XPToGive > 0 and Lvl < 100:\n        if getxptolevel(Lvl+1)-XPIntoLvl > XPToGive:\n            XPIntoLvl += XPToGive\n            XPToGive = 0\n        else:\n            XPToGive = XPToGive - (getxptolevel(Lvl+1)-XPIntoLvl)\n            Lvl += 1\n            AccLvl += 1\n            print(ID, \"reached level\", Lvl)\n            givelevelreward(ID, Lvl)\n            XPIntoLvl = 0\n    setlevel(ID, Lvl, XPIntoLvl)\n    setaccountlvl(ID, AccLvl)\n    return\n\ndef givelevelreward(player: str, lvl: int):\n    givebattlestars(player, getbattlestarperlvl(lvl))\n    return\n\ndef setlevel(player:str, lvl: int, XPIntoLvl: int):\n    JFile = readuserfile(player)\n    JFile[\"Level\"] = lvl\n    JFile[\"XPIntoLevel\"] = XPIntoLvl\n    with open(\"Accounts/\"+player+\".json\", \"w\") as savefile:\n        json.dump(JFile, savefile, indent=4)\n    return\n\ndef setaccountlvl(player:str, lvl: int):\n    JFile = readuserfile(player)\n    JFile[\"AccountLevel\"] = lvl\n    with open(\"Accounts/\"+player+\".json\", \"w\") as savefile:\n        json.dump(JFile, savefile, indent=4)\n    return\n\ndef givereward(Player:str, RewardID: int, Amount: int, Name: str): #0: vbucks, 1: XP, 2: BattleStars, 3: Skin, 4: Backpack, 5: Glider, 6: Pickaxe, 7: Contrail, 8: Loading screen, 9: Emote, 10: Challenge set\n    if RewardID == 0:\n        givevbucks(Player, Amount)\n    elif RewardID == 1:\n        givexp(Player, Amount)\n    elif RewardID == 2:\n        givebattlestars(Player, Amount)\n    elif RewardID == 3:\n        addskin(Player, Name)\n    elif RewardID == 4:\n        addbackpack(Player, Name)\n    elif RewardID == 5:\n        addglider(Player, Name)\n    elif RewardID == 6:\n        addpickaxe(Player, Name)\n    elif RewardID == 7:\n        addcontrail(Player, Name)\n    elif RewardID == 8:\n        addloadingscreen(Player, Name)\n    elif RewardID == 9:\n        addemote(Player, Name)\n    elif RewardID == 10:\n        givechallengeset(Player, Name)\n    addtorewardlist(Player, RewardID, Amount, Name)\n    return\n\n\ndef addtorewardlist(Player:str, RewardID: int, Amount: int, Name: str):\n    JFile = readuserfile(Player)\n    JFile[\"RewardsToBeClaimed\"].append({\"RewardID\": RewardID, \"Amount\": Amount, \"Name\": Name})\n    with open(\"Accounts/\"+Player+\".json\", \"w\") as savefile:\n        json.dump(JFile, savefile, indent=4)\n    return\n\ndef clearrewardlist(Player: str):\n    JFile = readuserfile(Player)\n    JFile[\"RewardsToBeClaimed\"] = []\n    with open(\"Accounts/\"+Player+\".json\", \"w\") as savefile:\n        json.dump(JFile, savefile, indent=4)\n    return\n\ndef givechallengeset(Player: str, SetName: str):\n    JFile = readuserfile(Player)\n    for set in JFile[\"ChallengeProgress\"]:\n        if set[\"Name\"] == SetName:\n            return\n    ChallengeSet = open(\"ChallengesSets/\"+SetName+\".json\", \"r\")\n    JChallengeSet = json.load(ChallengeSet)\n    JFile[\"ChallengeProgress\"].append({\"Name\": SetName, \"Completed\": False, \"Progression\": 0, \"Quests\": [{\"Completed\": False, \"Progress\": 0} for i in range(JChallengeSet[\"ChallengeCount\"])]})\n    with open(\"Accounts/\"+Player+\".json\", \"w\") as savefile:\n        json.dump(JFile, savefile, indent=4)\n    return\n\ndef progresschallenges(Player: str, challengeup):    #challengeup is a dictionary of the challgenges progressed:\n    challengelist = challengeup.keys()\n    JFile = readuserfile(Player)\n    RewardsToGive=[]   #Rewards are given after the process to avoid save bugs\n    for set in JFile[\"ChallengeProgress\"]:\n        if not set[\"Completed\"]:\n            ChallengeSet = open(\"ChallengesSets/\"+set[\"Name\"]+\".json\", \"r\")\n            JChallengeSet = json.load(ChallengeSet)\n            TempCompleted = 0\n            QuestID=-1\n            for quest in set[\"Quests\"]:\n                QuestID += 1\n                if quest[\"Completed\"]:\n                    TempCompleted += 1\n                else:\n                    if JChallengeSet[\"ChallengeList\"][QuestID][\"ChallengeName\"] in challengelist:\n                        quest[\"Progress\"] += challengeup[JChallengeSet[\"ChallengeList\"][QuestID][\"ChallengeName\"]]\n                        if quest[\"Progress\"] >= JChallengeSet[\"ChallengeList\"][QuestID][\"AmountToDo\"]:\n                            quest[\"Completed\"] = True\n                            TempCompleted += 1\n                            RewardsToGive.append({\"RewardID\": JChallengeSet[\"ChallengeList\"][QuestID][\"Reward\"][\"RewardID\"], \"Amount\": JChallengeSet[\"ChallengeList\"][QuestID][\"Reward\"][\"Amount\"], \"Name\": JChallengeSet[\"ChallengeList\"][QuestID][\"Reward\"][\"Name\"]})\n            if set[\"Progression\"] < JChallengeSet[\"ChallengesToGetReward\"] and TempCompleted >= JChallengeSet[\"ChallengesToGetReward\"]:\n                print(\"COMPLETED CHALLENGESET REWARD\")\n                RewardsToGive.append({\"RewardID\": JChallengeSet[\"Reward\"][\"RewardID\"], \"Amount\": JChallengeSet[\"Reward\"][\"Amount\"], \"Name\": JChallengeSet[\"Reward\"][\"Name\"]})\n            set[\"Progression\"] = TempCompleted\n            if TempCompleted == JChallengeSet[\"ChallengeCount\"]:\n                set[\"Completed\"] = True\n    with open(\"Accounts/\"+Player+\".json\", \"w\") as savefile:\n        json.dump(JFile, savefile, indent=4)\n    for i in RewardsToGive:\n        givereward(Player, i[\"RewardID\"], i[\"Amount\"], i[\"Name\"])\n    return                \n                \n\n\n\ndef givebattlestars(Player: str, Amount: int):\n    StarsToGive = Amount\n    Tier, Stars = gettier(Player)\n    while StarsToGive > 0 and Tier < 100:\n        if 10-Stars > StarsToGive:\n            Stars += StarsToGive\n            StarsToGive = 0\n            settier(Player, Tier, Stars)\n        else:\n            StarsToGive = StarsToGive - (10-Stars)\n            Tier += 1\n            print(Player, \"reached tier\", Tier)\n            Stars = 0\n            settier(Player, Tier, Stars)\n            givefreetierreward(Player, Tier)\n            givepremiumtierreward(Player, Tier)\n            \n    if StarsToGive>0 : \n        givexp(Player, StarsToGive*100) #each overflowing battlestar is converted to 100 xp\n    settier(Player, Tier, Stars)\n    return\n\ndef gettier(Player: str):\n    JFile = readuserfile(Player)\n    return JFile[\"BattlePassTier\"], JFile[\"BattleStarsCount\"]\n\ndef settier(player:str, tier: int, stars: int):\n    JFile = readuserfile(player)\n    JFile[\"BattlePassTier\"] = tier\n    JFile[\"BattleStarsCount\"] = stars\n    with open(\"Accounts/\"+player+\".json\", \"w\") as savefile:\n        json.dump(JFile, savefile, indent=4)\n    return\n\ndef activatepremiumpass(Player: str):\n    JFile = readuserfile(Player)\n    JFile[\"BattlePassPossessed\"] = True\n    Tier, _ = gettier(Player)\n    with open(\"Accounts/\"+Player+\".json\", \"w\") as savefile:\n        json.dump(JFile, savefile, indent=4)\n    for i in range(Tier):\n        givepremiumtierreward(Player, i+1)\n\n\n\ndef givefreetierreward(Player: str, Tier: int):\n    JFile = readuserfile(Player)\n    BP = json.load(open(\"BattlePass/FreePass.json\"))\n    if str(Tier) in BP[\"Rewards\"]:\n        givereward(Player, BP[\"Rewards\"][str(Tier)][\"RewardID\"], BP[\"Rewards\"][str(Tier)][\"Amount\"], BP[\"Rewards\"][str(Tier)][\"Name\"])\n    return\n    \n\ndef givepremiumtierreward(Player: str, Tier: int):\n    JFile = readuserfile(Player)\n    \n    if JFile[\"BattlePassPossessed\"]:\n        BP = json.load(open(\"BattlePass/Pass.json\"))\n        givereward(Player, BP[\"Rewards\"][str(Tier)][\"RewardID\"], BP[\"Rewards\"][str(Tier)][\"Amount\"], BP[\"Rewards\"][str(Tier)][\"Name\"])\n        return\n\n\ndef givevbucks(Player: str, Amount: int):\n    JFile = readuserfile(Player)\n    JFile[\"VBucksCount\"] = JFile[\"VBucksCount\"] + Amount\n    print(\"Gave\", Amount, \"VBucks to\", Player)\n    with open(\"Accounts/\"+Player+\".json\", \"w\") as savefile:\n        json.dump(JFile, savefile, indent=4)\n    return\n\ndef canaffordvbucks(Player: str, Amount: int):\n    JFile = readuserfile(Player)\n    return JFile[\"VBucksCount\"] >= Amount\n\ndef removevbucks(Player: str, Amount: int):\n    JFile = readuserfile(Player)\n    JFile[\"VBucksCount\"] = JFile[\"VBucksCount\"] - Amount\n    print(\"Removed\", Amount, \"VBucks from\", Player)\n    with open(\"Accounts/\"+Player+\".json\", \"w\") as savefile:\n        json.dump(JFile, savefile, indent=4)\n\n\n\n\n\ndef setskin(Player: str, CosmeticName: str):\n    JFile = readuserfile(Player)\n    JFile[\"Locker\"][\"Skin\"] = CosmeticName\n    with open(\"Accounts/\"+Player+\".json\", \"w\") as savefile:\n        json.dump(JFile, savefile, indent=4)\n    return\n\ndef setbackpack(Player: str, CosmeticName: str):\n    JFile = readuserfile(Player)\n    JFile[\"Locker\"][\"Backpack\"] = CosmeticName\n    with open(\"Accounts/\"+Player+\".json\", \"w\") as savefile:\n        json.dump(JFile, savefile, indent=4)\n    return\n\ndef setglider(Player: str, CosmeticName: str):\n    JFile = readuserfile(Player)\n    JFile[\"Locker\"][\"Glider\"] = CosmeticName\n    with open(\"Accounts/\"+Player+\".json\", \"w\") as savefile:\n        json.dump(JFile, savefile, indent=4)\n    return\n\ndef setpickaxe(Player: str, CosmeticName: str):\n    JFile = readuserfile(Player)\n    JFile[\"Locker\"][\"Pickaxe\"] = CosmeticName\n    with open(\"Accounts/\"+Player+\".json\", \"w\") as savefile:\n        json.dump(JFile, savefile, indent=4)\n    return\n\ndef setcontrail(Player: str, CosmeticName: str):\n    JFile = readuserfile(Player)\n    JFile[\"Locker\"][\"Contrail\"] = CosmeticName\n    with open(\"Accounts/\"+Player+\".json\", \"w\") as savefile:\n        json.dump(JFile, savefile, indent=4)\n    return\n\ndef setloadingscreen(Player: str, CosmeticName: str):\n    JFile = readuserfile(Player)\n    JFile[\"Locker\"][\"LoadingScreen\"] = CosmeticName\n    with open(\"Accounts/\"+Player+\".json\", \"w\") as savefile:\n        json.dump(JFile, savefile, indent=4)\n    return\n\ndef setemote1(Player: str, CosmeticName: str):\n    JFile = readuserfile(Player)\n    JFile[\"Locker\"][\"Emote1\"] = CosmeticName\n    with open(\"Accounts/\"+Player+\".json\", \"w\") as savefile:\n        json.dump(JFile, savefile, indent=4)\n    return\n\ndef setemote2(Player: str, CosmeticName: str):\n    JFile = readuserfile(Player)\n    JFile[\"Locker\"][\"Emote2\"] = CosmeticName\n    with open(\"Accounts/\"+Player+\".json\", \"w\") as savefile:\n        json.dump(JFile, savefile, indent=4)\n    return\n\ndef setemote3(Player: str, CosmeticName: str):\n    JFile = readuserfile(Player)\n    JFile[\"Locker\"][\"Emote3\"] = CosmeticName\n    with open(\"Accounts/\"+Player+\".json\", \"w\") as savefile:\n        json.dump(JFile, savefile, indent=4)\n    return\n\ndef setemote4(Player: str, CosmeticName: str):\n    JFile = readuserfile(Player)\n    JFile[\"Locker\"][\"Emote4\"] = CosmeticName\n    with open(\"Accounts/\"+Player+\".json\", \"w\") as savefile:\n        json.dump(JFile, savefile, indent=4)\n    return\n\ndef setemote5(Player: str, CosmeticName: str):\n    JFile = readuserfile(Player)\n    JFile[\"Locker\"][\"Emote5\"] = CosmeticName\n    with open(\"Accounts/\"+Player+\".json\", \"w\") as savefile:\n        json.dump(JFile, savefile, indent=4)\n    return\n\ndef setemote6(Player: str, CosmeticName: str):\n    JFile = readuserfile(Player)\n    JFile[\"Locker\"][\"Emote6\"] = CosmeticName\n    with open(\"Accounts/\"+Player+\".json\", \"w\") as savefile:\n        json.dump(JFile, savefile, indent=4)\n    return\n\n\ndef getequippedlocker(Player: str):\n    JFile = readuserfile(Player)\n    return [JFile[\"Locker\"][\"Skin\"], JFile[\"Locker\"][\"Backpack\"], JFile[\"Locker\"][\"Glider\"], JFile[\"Locker\"][\"Pickaxe\"], JFile[\"Locker\"][\"Contrail\"], JFile[\"Locker\"][\"LoadingScreen\"], JFile[\"Locker\"][\"Emote1\"], JFile[\"Locker\"][\"Emote2\"], JFile[\"Locker\"][\"Emote3\"], JFile[\"Locker\"][\"Emote4\"], JFile[\"Locker\"][\"Emote5\"], JFile[\"Locker\"][\"Emote6\"]]\n\ndef getlocker(Player: str):\n    JFile = readuserfile(Player)\n    return [JFile[\"Locker\"][\"Skins\"], JFile[\"Locker\"][\"Backpacks\"], JFile[\"Locker\"][\"Gliders\"], JFile[\"Locker\"][\"Pickaxes\"], JFile[\"Locker\"][\"Contrails\"], JFile[\"Locker\"][\"LoadingScreens\"], JFile[\"Locker\"][\"Emotes\"]]\n\n\ndef addskin(Player: str, Name: str):\n    JFile=readuserfile(Player)\n    JFile[\"Locker\"][\"Skins\"].extend([Name])\n    with open(\"Accounts/\"+Player+\".json\", \"w\") as savefile:\n        json.dump(JFile, savefile, indent=4)\n    return\n\ndef addbackpack(Player: str, Name: str):\n    JFile=readuserfile(Player)\n    JFile[\"Locker\"][\"Backpacks\"].extend([Name])\n    with open(\"Accounts/\"+Player+\".json\", \"w\") as savefile:\n        json.dump(JFile, savefile, indent=4)\n    return\n\ndef addglider(Player: str, Name: str):\n    JFile=readuserfile(Player)\n    JFile[\"Locker\"][\"Gliders\"].extend([Name])\n    with open(\"Accounts/\"+Player+\".json\", \"w\") as savefile:\n        json.dump(JFile, savefile, indent=4)\n    return\n\ndef addpickaxe(Player: str, Name: str):\n    JFile=readuserfile(Player)\n    JFile[\"Locker\"][\"Pickaxes\"].extend([Name])\n    with open(\"Accounts/\"+Player+\".json\", \"w\") as savefile:\n        json.dump(JFile, savefile, indent=4)\n    return\n\ndef addcontrail(Player: str, Name: str):\n    JFile=readuserfile(Player)\n    JFile[\"Locker\"][\"Contrails\"].extend([Name])\n    with open(\"Accounts/\"+Player+\".json\", \"w\") as savefile:\n        json.dump(JFile, savefile, indent=4)\n    return\n\ndef addloadingscreen(Player: str, Name: str):\n    JFile=readuserfile(Player)\n    JFile[\"Locker\"][\"LoadingScreens\"].extend([Name])\n    with open(\"Accounts/\"+Player+\".json\", \"w\") as savefile:\n        json.dump(JFile, savefile, indent=4)\n    return\n\ndef addemote(Player: str, Name: str):\n    JFile=readuserfile(Player)\n    JFile[\"Locker\"][\"Emotes\"].extend([Name])\n    with open(\"Accounts/\"+Player+\".json\", \"w\") as savefile:\n        json.dump(JFile, savefile, indent=4)\n    return\n\n\n#Matchmaking system\n\nscheduler = sched.scheduler(time.time, time.sleep)\n\nclass MatchQueue:\n    def __init__(self, ServerIP: str, MaxPlayers: int, MaxTime: int, MatchID:int):\n        self.ServerIP = ServerIP\n        self.MaxPlayers = MaxPlayers\n        self.MaxTime = MaxTime\n        self.Started = False\n        self.MatchID=MatchID\n        self.PlayersInQueue = 0\n        #if MaxTime != 0:\n        #    print(\"Delay of\", MaxTime,\"seconds\")\n        #    scheduler.enter(delay=MaxTime, action=MatchTimeOut, argument=(MatchID,), priority=1)\n        #    scheduler.run()\n\nMatchQueues = {} #ID(int):Queue(Object)\nPlayerQueue = []\nPlayerMoved = {} #PlayerID(int):MatchID(int), used to give players their matchID\n\nmain_loop = None\nserver_process = None\ndef start_server():\n    global server_process\n    exe_path = r\"D:\\Unreal Projects\\Meteor\\Builds\\1.0.0 Beta 2\\Server\\BRSolo\\WindowsServer\\MeteorServer.exe\"\n\n    if not os.path.exists(exe_path):\n        print(\"Executable not found.\")\n        return\n\n    server_process = subprocess.Popen(exe_path)\n    print(f\"Server started with PID: {server_process.pid}\")\n\ndef stop_server():\n    global server_process\n    print(f\"Terminating process with PID {server_process.pid}\")\n    server_process.terminate()\n    server_process.wait()\n    server_process = None\n    print(\"Server terminated.\")\n\n\n\ndef creatematchqueue(ServIP: str, MaxPlrs: int, MaxTme: int):\n    MatchID:int = random.randint(1000000, 9999999)\n    tempmatch = MatchQueue(ServerIP=ServIP, MaxPlayers=MaxPlrs, MaxTime=MaxTme, MatchID=MatchID)\n    MatchQueues[MatchID] = tempmatch\n    print(\"MATCH CREATED Created match with ID\", MatchID)\n    fillqueue(MatchID)\n    if MaxTme > 0:\n        main_loop.create_task(starttimeouttimer(MatchID, MaxTme))\n    return MatchID\n\nasync def starttimeouttimer(MatchID: int, Time: int):\n    print(\"Started time out timer for match\", MatchID)\n    await asyncio.sleep(Time)\n    MatchTimeOut(MatchID)\n\ndef MatchTimeOut(MatchID:int):\n    if MatchID in MatchQueues:\n        print(\"CALLED MATCH TIMEOUT\")\n        if not MatchQueues[MatchID].Started:\n            StartMatch(MatchID)\n            print(\"Match\", MatchID, \"timed out.\")\n    return\n\ndef StartMatch(MatchID:int):\n    if MatchID in MatchQueues:\n        if not MatchQueues[MatchID].Started:\n            start_server()\n            MatchQueues[MatchID].Started = True\n            print(\"Match\", MatchID, \"started\")\n            main_loop.create_task(startdeletetimer(MatchID))\n            \n    return\n\nasync def startdeletetimer(MatchID: int):\n    print(\"Started timer to delete match\", MatchID)\n    await asyncio.sleep(20)\n    DeleteMatchFromList(MatchID)\n\n\ndef DeleteMatchFromList(MatchID:int):\n    del MatchQueues[MatchID]\n    print(\"MatchMaking : Removed match\", MatchID, \"from the list\")\n    return\n\ndef findmatch():\n    if MatchQueues:\n        for i in MatchQueues.values():\n            if not i.Started:\n                i.PlayersInQueue += 1\n                if i.PlayersInQueue == i.MaxPlayers:\n                    StartMatch(MatchQueues[list(MatchQueues)[i]])\n                return {\"MatchID\":i.MatchID}\n    MatchmakerPlayerID:int = random.randint(1000000, 9999999)\n    PlayerQueue.append(MatchmakerPlayerID)\n    return {\"MatchmakerPlayerID\": MatchmakerPlayerID}\n    \ndef leavequeue(MatchOrPlayerID:int):\n    if MatchOrPlayerID in MatchQueues:\n        MatchQueues[MatchOrPlayerID].PlayersInQueue -= 1\n        fillqueue(MatchOrPlayerID)\n    elif MatchOrPlayerID in PlayerQueue:\n        PlayerQueue.remove(MatchOrPlayerID)\n    elif MatchOrPlayerID in PlayerMoved:\n        tempPlayer = PlayerMoved[MatchOrPlayerID]\n        del PlayerMoved[MatchOrPlayerID]\n        leavequeue(tempPlayer)\n    return {\"Log\": \"OK\"}\n\ndef fillqueue(MatchID:int):\n    for i in range(MatchQueues[MatchID].MaxPlayers-MatchQueues[MatchID].PlayersInQueue):\n        if PlayerQueue:\n            PlayerMoved[PlayerQueue[0]] = MatchID\n            del PlayerQueue[0]\n        else:\n            MatchQueues[MatchID].PlayersInQueue += 1\n            if MatchQueues[MatchID].PlayersInQueue == MatchQueues[MatchID].MaxPlayers:\n                    StartMatch(MatchID)\n            return\n    return\n\ndef getfindmatchstate(MatchmakerPlayerID:int):\n    if MatchmakerPlayerID in PlayerQueue:\n        return{\"log\":\"InQueue\",\"PosInQueue\": PlayerQueue.index(MatchmakerPlayerID), \"PlayersInQueue\": len(PlayerQueue)}\n    if MatchmakerPlayerID in PlayerMoved:\n        TempMatchID = PlayerMoved[MatchmakerPlayerID]\n        TempPlayersInQueue = MatchQueues[PlayerMoved[MatchmakerPlayerID]].PlayersInQueue\n        del PlayerMoved[MatchmakerPlayerID]\n        return{\"log\": \"FoundMatch\",\"MatchID\": TempMatchID,\"PlayersInQueue\": TempPlayersInQueue}\n    return {\"log\": \"MatchmakerPlayerID not found\"}\n\ndef getmatchstate(MatchID:int):\n    if MatchID in MatchQueues:\n        if MatchQueues[MatchID].Started:\n            print(\"Sent server IP :\", MatchQueues[MatchID].ServerIP)\n            return {\"log\": \"ok\", \"ServerIP\": MatchQueues[MatchID].ServerIP}\n        else :\n            return {\"log\": \"ok\", \"PlayersInQueue\": MatchQueues[MatchID].PlayersInQueue}\n    return {\"log\": \"error\"}\n\n@app.get(\"/matchmaking/dev/creatematch\")   #Called by a bat file for now\ndef appcreatematch(Pass: str, ServerIP: str, MaxPlayers: int, MaxTime: int):\n    if Pass == \"azertyuiop\":\n        return creatematchqueue(ServIP=ServerIP, MaxPlrs=MaxPlayers, MaxTme=MaxTime)\n    \n@app.get(\"/matchmaking/dev/startmatch\")    #Called by a bat file if the launch is not automatic\ndef appstartmatch(MatchID:int, Pass: str):\n    if Pass == \"azertyuiop\":\n        #return StartMatch(MatchID=MatchID)\n        return StartMatch(list(MatchQueues.keys())[0])\n    \n@app.get(\"/matchmaking/findmatch\")\ndef appfindmatch():\n    return findmatch()\n\n@app.get(\"/matchmaking/leavequeue\")\ndef appleavequeue(MatchOrPlayerID:int):\n    return leavequeue(MatchOrPlayerID=MatchOrPlayerID)\n\n@app.get(\"/matchmaking/getfindmatchstate\")\ndef appgetfindmatchstate(MatchmakerPlayerID:int):\n    return getfindmatchstate(MatchmakerPlayerID)\n\n@app.get(\"/matchmaking/getmatchstate\")\ndef appgetmatchstate(MatchID:int):\n    return getmatchstate(MatchID)\n\n\n\n#givechallengeset(\"123456\", \"Week0\")\n#progresschallenges(\"123456\", {\"AmmoBoxes\":30,\"Kills\":2})\n#progresschallenges(\"123456\", {\"Kills\": 4})\n#progresschallenges(\"123456\", {\"ChestTilted\": 8})\n#progresschallenges(\"123456\", {\"DamageAR\": 1040})\n\n@app.on_event(\"startup\")\nasync def on_startup():\n    global main_loop\n    \n    main_loop = asyncio.get_running_loop()\n    \n\nif __name__ == \"__main__\":\n    uvicorn.run(app, host=\"127.0.0.1\", port=8000)\n\n\n","size_bytes":34220},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"bcrypt>=4.3.0\",\n    \"fastapi>=0.116.1\",\n    \"pydantic>=2.11.7\",\n    \"uvicorn>=0.35.0\",\n]\n","size_bytes":236},"replit.md":{"content":"# MeteorBackend\n\n## Overview\n\nMeteorBackend is a FastAPI-based game server that provides user management and progression systems for what appears to be a Fortnite-like battle royale game. The system manages player accounts, battle passes, challenges, item shops, cosmetic lockers, and player statistics. It implements a complete progression system with XP, levels, battle pass tiers, challenges, and in-game currency (V-Bucks and Battle Stars).\n\n## User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n## System Architecture\n\n### Backend Framework\n- **FastAPI**: RESTful API server handling all game backend operations\n- **File-based Storage**: JSON files for all data persistence instead of a traditional database\n- **Token-based Authentication**: Custom token system for user session management\n\n### Authentication System\n- **Password Hashing**: Uses bcrypt for secure password storage\n- **Token Management**: In-memory token dictionary mapping usernames to authentication tokens\n- **Account Creation**: Supports new user registration with hashed passwords\n\n### Data Storage Architecture\n- **JSON File System**: All game data stored as JSON files in organized directories\n  - `/Accounts/`: Individual player account files\n  - `/BattlePass/`: Battle pass reward structures\n  - `/ChallengesSets/`: Different challenge configurations\n  - `/Shop/`: Item shop configurations\n- **Template System**: Uses default account templates for new user creation\n\n### Game Progression System\n- **Level System**: XP-based progression with formula y = 200*y for level requirements\n- **Battle Pass**: Free and premium tier reward systems with cosmetic unlocks\n- **Challenge System**: Multi-tier challenge sets with various objectives and rewards\n- **Reward Types**: Supports multiple reward categories (XP, V-Bucks, Battle Stars, cosmetics)\n\n### Cosmetic Management\n- **Locker System**: Comprehensive cosmetic inventory management\n  - Skins, Backpacks, Gliders, Pickaxes, Contrails, Loading Screens, Emotes\n  - Loadout configuration for equipped items\n- **Item Categories**: Structured cosmetic item system with unique identifiers\n\n### Challenge and Progression Tracking\n- **Challenge Sets**: Modular challenge system supporting different difficulty tiers\n- **Progress Tracking**: Individual challenge progress stored per user\n- **Reward Distribution**: Automated reward claiming system\n\n## External Dependencies\n\n### Core Dependencies\n- **FastAPI**: Web framework for API endpoints\n- **uvicorn**: ASGI server for running the FastAPI application\n- **bcrypt**: Cryptographic library for password hashing\n- **pydantic**: Data validation and settings management\n\n### Development Dependencies\n- **Python Standard Library**: Uses json, os, random, string, time, subprocess, asyncio for core functionality\n- **sched**: Task scheduling capabilities (imported but usage not visible in provided code)\n\n### File System Dependencies\n- Relies on local file system for all data persistence\n- No external database connections required\n- JSON file structure for all game data storage","size_bytes":3074}},"version":1}